package com.zerokikr.lesson7;

/* 
 * Класс Integer - immutable (если создал - нельзя изменить). Если синхронизировать треды по объекту-монитору класса Integer и внутри тредов 
 * 	  менять значение этого объекта, то синхронизации не будет (в каждом треде будет создаваться новый объект
 * 		и переменная будет ссылаться на него).
 * 
 * SingleThreadPool -> пул потоков на 1 тред.
 * FixedThreadPool (4) -> пул потоков с ограничением (4).
 * CachedThreadPool -> пул потоков без ограничения. Попытается создавать тред для каждой задачи, даже если их очень много.
 * 		Отключает треды после 60 сек. бездействия.
 * 
 * Если тред пул запущен, то его треды будут оставаться рабочими (приложение продолжит работать).
 * 		Метод service.shutdown() выключает неактивные потоки, ждет когда отработают активные и переводит
 * 			 service в состояние terminated (заново запустить невозможно).
 * 
 * Метод shutdownNow() посылает команду interrupt() всем тредам сервиса.
 * 	 Если у треда настроено isInterrupted(), он моментально остановится. Если не настроено, то
 * 		shutdownNow() ведет себя как обычный shutdown().
 * 
 * Из обычного треда исключения не вылетают в main тред:
 * 	t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){}) позволяет описать,
 * 	  что делать в случае исключений, выброшенных и не обработанных тредом. 
 * 		Нужно создавать для каждого конкретного треда.
 * 
 * Thread.setDefaultExceptionHandler(new Thread.UncaughtExceptionHandler(){}) 
 * 	Можно создать один для всех тредов.
 * 
 * Метод service.submit возвращает объект типа Future<> (информация о выполненемой задаче) и принимает
 * 	 анонимный внутренний класс Callable <>. Затем нужно переопределить метод call(),
 * 		 который будiterativeFactorialет возвращать результат во время работы треда, который запущен сервисом. 
 * 
 * При использовании java.util.concurrent.locks.Lock стоит использовать try-finally или try-catch-finally,
 * 	 и в блоке finally делать lock.unlock(), т.к. код в блоке finally выполняется всегда,
 * 	   даже если вылетело исключение. Иначе Lock останется закрытым всегда.
 * 
 */


public class ThreadInfo2 {

}
